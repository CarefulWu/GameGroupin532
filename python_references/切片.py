# 一个完整的切片表达式包含两个 “:”，用于分隔三个参数(start_index、end_index、step)，当只有一个“:” 时，默认第三个参数 step=1。
# 切片操作基本表达式：object[start_index:end_index:step]
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# print(a[:])
# print(a[::])
# print(a[::-1])

# >>>a[1:6:-1]
# >>> []
# 输出为空列表，说明没取到数据。
# step=-1，决定了从右往左取值，而start_index=1到end_index=6决定了从左往右取值，两者矛盾，所以为空。
# print(a[1:6:-1])

# >>>a[6:1]
# >>> []
# 同样输出为空列表。
# step=1，决定了从左往右取值，而start_index=6到end_index=1决定了从右往左取值，两者矛盾，所以为空。
# print(a[6:1])

# >>>a[-1:-6:-1]
# >>> [9, 8, 7, 6, 5]
# step=-1，从右往左取值，start_index=-1到end_index=-6同样是从右往左取值。
# 索引-1在6的右边（如上图）

# >>>a[-1:6:-1]
# >>> [9, 8, 7]
# start_index=-1在end_index=6的右边，因此从右往左取值，而step=-1同样决定了从右往左取值，因此结果正确。

# 连续切片操作
# >>>a[:8][2:5][-1:]
# >>> [4]
# 相当于：
# a[:8]=[0, 1, 2, 3, 4, 5, 6, 7]
# a[:8][2:5]= [2, 3, 4]
# a[:8][2:5][-1:] = 4
# 理论上可无限次连续切片操作，只要上一次返回的依然是非空可切片对象。

# 前面的切片操作说明都以 list 为例进行说明，但实际上可进行的切片操作的数据类型还有很多，包括元组、字符串等等。
#
# >>> (0, 1, 2, 3, 4, 5)[:3]
# >>> (0, 1, 2)
# 元组的切片操作
#
# >>>'ABCDEFG'[::2]
# >>>'ACEG'
# 字符串的切片操作
#
# >>>for i in range(1,100)[2::3][-10:]:
#        print(i)
# 就是利用range函数生成1-99的整数，然后取3的倍数，再取最后十个。


# 拷贝整个对象
# >>>b = a[:]
# >>>print(b)
# >>>print(id(a))
# >>>print(id(b))
# 或
# >>>b = a.copy()
# >>>print(b)
# >>>print(id(a))
# >>>print(id(b))

# 需要注意的是：[:] 和. copy() 都属于 “浅拷贝”，只拷贝最外层元素，内层嵌套元素则通过引用，而不是独立分配内存。
#
# >>>a = [1,2,['A','B']]
# >>>print('a={}'.format(a))
# >>>b = a[:]
# >>>b[0] = 9
# >>>b[2][0] = 'D'
# >>>print('a={}'.format(a))
# >>>print('b={}'.format(b))
# >>>print('id(a)={}'.format(id(a)))
# >>>print('id(b)={}'.format(id(b)))
# a=[1, 2, ['A', 'B']]
# a=[1, 2, ['D', 'B']]
# b=[9, 2, ['D', 'B']]
# id(a)=38669128
# id(b)=38669192
#
# 在某个位置插入元素
# >>>a[3:3] = ['A','B','C']
# [0, 1, 2, 'A', 'B', 'C', 3, 4, 5, 6, 7, 8, 9]
# >>>a[0:0] = ['A','B']
# ['A', 'B', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# a[0:0] = "Hello"
# print(a)                   ['H', 'e', 'l', 'l', 'o', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

